"""
This script is used to refactor the ffi skeleton code.

The ffi skeleton code is generated by the following command:

```
python apps/refactor_ffi.py folder_path --refactor --inplace
```

The refactored code is saved in the same folder, instruction is as follows:

This file provides the high-level skeleton for agent to generate
the real implemenation


I would like to refactor the global function registeration FFI patterns
from TVM_FFI_REGISTER_GLOBAL to GlobalDef. The rules are roughly as follows:

- Change TVM_FFI_REGISTER_GLOBAL to GlobalDef
   - You can find occurance by running a grep of TVM_FFI_REGISTER_GLOBAL
- Surround the GlobalDef with TVM_FFI_STATIC_INIT_BLOCK
- For registration call to set_body, change to def_packed
- For registration call to set_body_typed, change to def
- For registration call to set_body_method, change to def_method

Pay very close attention to the following:
- If the file do not yet include tvm/ffi/reflection/reflection.h, add an include to it, follow google c style.
- Do not attempt to refactor the function being registered, copy the exact content over
- Copy the exact same name in TVM_FFI_REGISTER_GLOBAL to the name in defs
- Place TVM_FFI_STATIC_INIT_BLOCK EXACTLY in the original location of registrations
  - Only if there are consecutive registrations that are next to each other, group them into the a single block
- Do not attempt to move the registration locaiton
- Try generate patch for each TVM_FFI_REGISTER_GLOBAL one by one

I will ask you to do such refactor for cc files, likely you don't have to touch header files.
Let me show you an example before and after

Before

```c++

TVM_FFI_REGISTER_GLOBAL("tvm.contrib.hipblas.matmul")
    .set_body_packed([](ffi::PackedArgs args, ffi::Any* ret) {
      auto A = args[0].cast<DLTensor*>();
      auto C = args[2].cast<DLTensor*>();

      HipBlasThreadEntry* entry_ptr = HipBlasThreadEntry::ThreadLocal();

      if (TypeEqual(A->dtype, C->dtype)) {
        ICHECK(TypeMatch(A->dtype, kDLFloat, 16) || TypeMatch(A->dtype, kDLFloat, 32) ||
               TypeMatch(A->dtype, kDLFloat, 64));

        if (TypeMatch(A->dtype, kDLFloat, 16)) {
          CallGemm(args, ret, HipblasHgemmOp(entry_ptr->handle));
        } else if (TypeMatch(A->dtype, kDLFloat, 32)) {
          CallGemm(args, ret, HipblasSgemmOp(entry_ptr->handle));
        } else {
          CallGemm(args, ret, HipblasDgemmOp(entry_ptr->handle));
        }
      } else {
        CallGemmEx(args, ret, entry_ptr->handle);
      }
    });

TVM_FFI_REGISTER_GLOBAL("tvm.contrib.hipblas.batch_matmul")
    .set_body_packed([](ffi::PackedArgs args, ffi::Any* ret) {
      auto A = args[0].cast<DLTensor*>();
      auto C = args[2].cast<DLTensor*>();

      HipBlasThreadEntry* entry_ptr = HipBlasThreadEntry::ThreadLocal();

      if (TypeEqual(A->dtype, C->dtype)) {
        ICHECK(TypeMatch(A->dtype, kDLFloat, 16) || TypeMatch(A->dtype, kDLFloat, 32) ||
               TypeMatch(A->dtype, kDLFloat, 64));

        if (TypeMatch(A->dtype, kDLFloat, 16)) {
          CallBatchGemm(args, ret, HipblasHgemmBatchOp(entry_ptr->handle));
        } else if (TypeMatch(A->dtype, kDLFloat, 32)) {
          CallBatchGemm(args, ret, HipblasSgemmBatchOp(entry_ptr->handle));
        } else {
          CallBatchGemm(args, ret, HipblasDgemmBatchOp(entry_ptr->handle));
        }
      } else {
        CallBatchGemmEx(args, ret, entry_ptr->handle);
      }
    });
```

after
```
TVM_FFI_STATIC_INIT_BLOCK({
  namespace refl = tvm::ffi::reflection;
  refl::GlobalDef()
    .def_packed("tvm.contrib.hipblas.matmul", [](ffi::PackedArgs args, ffi::Any* ret) {
      auto A = args[0].cast<DLTensor*>();
      auto C = args[2].cast<DLTensor*>();

      HipBlasThreadEntry* entry_ptr = HipBlasThreadEntry::ThreadLocal();

      if (TypeEqual(A->dtype, C->dtype)) {
        ICHECK(TypeMatch(A->dtype, kDLFloat, 16) || TypeMatch(A->dtype, kDLFloat, 32) ||
               TypeMatch(A->dtype, kDLFloat, 64));

        if (TypeMatch(A->dtype, kDLFloat, 16)) {
          CallGemm(args, ret, HipblasHgemmOp(entry_ptr->handle));
        } else if (TypeMatch(A->dtype, kDLFloat, 32)) {
          CallGemm(args, ret, HipblasSgemmOp(entry_ptr->handle));
        } else {
          CallGemm(args, ret, HipblasDgemmOp(entry_ptr->handle));
        }
      } else {
        CallGemmEx(args, ret, entry_ptr->handle);
      }
    })
    .def_packed("tvm.contrib.hipblas.batch_matmul", [](ffi::PackedArgs args, ffi::Any* ret) {
      auto A = args[0].cast<DLTensor*>();
      auto C = args[2].cast<DLTensor*>();

      HipBlasThreadEntry* entry_ptr = HipBlasThreadEntry::ThreadLocal();

      if (TypeEqual(A->dtype, C->dtype)) {
        ICHECK(TypeMatch(A->dtype, kDLFloat, 16) || TypeMatch(A->dtype, kDLFloat, 32) ||
               TypeMatch(A->dtype, kDLFloat, 64));

        if (TypeMatch(A->dtype, kDLFloat, 16)) {
          CallBatchGemm(args, ret, HipblasHgemmBatchOp(entry_ptr->handle));
        } else if (TypeMatch(A->dtype, kDLFloat, 32)) {
          CallBatchGemm(args, ret, HipblasSgemmBatchOp(entry_ptr->handle));
        } else {
          CallBatchGemm(args, ret, HipblasDgemmBatchOp(entry_ptr->handle));
        }
      } else {
        CallBatchGemmEx(args, ret, entry_ptr->handle);
      }
    });
});
```

Try to write a python script to run the replacement for files under a folder, you can use the following strategy
- You just need to count () for both finding name in TVM_FFI_REGISTER_GLOBAL
- You can also count () to find the begin end of the function, be it lambda or name, no need to count other things likely
- We do need to pay attention to comment and string where we should nto count ()
- Try write unit testcase first to confirm you can successfully extract the begin end line, char location of the function body
- Do exact copy of function body content

When generating the refactor_ffi.py no need to output the instruction above
"""
import namedtuple
import argparse

"""
Entry to store the information of the function registration to be extracted from the file

- lineno_begin: the line number of the first line of the function registration
- lineno_end: the line number of the last line of the function registration
- method: the method of the function registration, can be packed, typed, method
- name: the name of the function registration
- function: the function body of the function registration
"""
Entry = namedtuple("Entry", ["lineno_begin", "lineno_end", "method", "name", "function"])


def extract_registration_entries(lines):
    """
    Extract the registration entries from the file

    Parameters
    ----------
    lines: list[str]
        The lines of the file

    Returns
    -------
    entries: list[Entry]
        The list of registration entries
    """
    # implement this function


def print_entries(entries):
    """
    Print the registration entries to the screen in the following example

    ```
    file_name.cc [lineno_begin:lineno_end): name=<name>, method=<method>
    ====================================================================
    <function>
    ...
    ```
    """
    # implement this function


def update_insert_task_with_include_reflection_h(lines, insert_task):
    """
    TODO: detect if the file already #include <tvm/ffi/reflection/reflection.h>
    if not, add an include to it, follow google c style
    if it does, do not add it again
    make sure to add the include after the initial ASF header
    """
    # implement this function
    pass


def print_diff(original_lines, delete_task, insert_task):
    """

    TODO: print out the diff line indicated by the delete_task (look up original lines)
    insert_task simply just print out the new lines, in both cases, print out the line number range
    Parameters
    ----------
    original_lines: list[str]
        The original lines of the file
    delete_task: set[int]
    """
    # implement this function
    pass

def refactor_file_content(lines, entries):
    """
    Refactor the file content for given entries information

    Parameters
    ----------
    lines: list[str]
        The lines of the file

    entries: list[Entry]
        The list of registration entries

    Returns
    -------
    content: str
        The refactored content of the file
    """
    assert len(entries) > 0, "No entries to refactor"

    delete_task = set()
    for entry in entries:
      delete_task.update(range(entry.lineno_begin, entry.lineno_end))

    # Dict[int, str] task to insert the new line in corresponding position
    insert_task = {}

    update_insert_task_with_include_reflection_h(lines, insert_task)

    # TODO: generate insert task here
    # Please generate the TVM_FFI_STATIC_INIT_BLOCK and the GlobalDef here
    # Please generate the def_packed, def, def_method here based on entries
    # also run detection of consecutive entries by checking if lines between them
    # only conâ€ ains whitespace, if so, build a single insert_task, also add the blank line
    # into delete_task

    output_lines = []
    for i, line in enumerate(lines):
      if i in delete_task:
        continue
      if i in insert_task:
        output_lines.append(insert_task[i])
    print_diff(lines, delete_task, insert_task)

    return '\n'.join(output_lines)



def main():
    """
    Main function to run the refactor, use argparse
    """
    # implement this function
    pass


if __name__ == "__main__":
    main()
